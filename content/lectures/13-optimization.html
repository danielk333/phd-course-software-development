---
title: "Optimization"
description: ""
handout: optimization
weight: 13
---

<div class="reveal">
    <div class="slides">

        <section
            data-auto-animate
            data-background-image="media/c_python_funny.png"
            data-background-opacity="1"
        >
            <div class="centered-container"></div>
        </section>

        <section
            data-auto-animate
            data-background-image="media/c_python_funny.png"
            data-background-opacity="0.1"
        >
            <div class="centered-container">
                <h3 class="title">Optimization</h3>
                <p class="fragment">This topic is way too vast to cover in one lecture</p>
                <p class="fragment">So today we will cover:</p>
                <ul class="fragment">
                    <li>Vectorization vs Vectorization</li>
                    <li>Shaving operations</li>
                    <li>Choosing the correct algorithm</li>
                    <li>Compiled languages and automatic optimizers</li>
                    <li>Approximations</li>
                    <li>Digging deep (compiled assembly)</li>
                </ul>
            </div>
        </section>

        <section
            data-auto-animate
        >
            <div class="centered-container">
                <h3 class="title">Optimization</h3>
                <ul>
                    <li>Vectorization vs Vectorization</li>
                </ul>
                <p class="fragment mark">Data vectorization</p>
                <p class="fragment">An example: Mandelbrot set calculation</p>
                <div class="fragment">
                    $$
                    z_{n+1} = z_n + c
                    $$
                    $$
                    z_0 = 0,\; z_n \in \mathbb{C},\; z_n \mapsto \infty?
                    $$
                </div>
                <img src="media/mandelbrot.png" class="fragment light" style="height: 20vh;">
            </div>
        </section>

        <section
            data-auto-animate
        >
            <div class="centered-container">
                <h3 class="title">Optimization</h3>
                <ul>
                    <li>Vectorization vs Vectorization</li>
                </ul>
                <img src="media/mandelbrot.png" class="light" style="height: 65vh;">
            </div>
        </section>

        <section
            data-auto-animate
        >
            <div class="centered-container">
                <h3 class="title">Optimization</h3>
                <pre data-id="code-animation" class="fragment show-code">
                    <code data-line-numbers data-trim class="language-python" style="height: 60vh;">
                        import time
                        import numpy as np


                        def iter_fun(zn, C):
                            return zn**2 + C


                        def iter_n_loop(z0, C, max_num, limit):
                            z = z0 * np.ones(C.shape, dtype=C.dtype)

                            mat_shape = z.shape
                            mat_size = z.size

                            # we only iterate until the limit is passed, then it is considered divergant
                            # use the "iters" as a indication of this
                            iters = np.zeros((mat_size,), dtype=np.int32)

                            # flatten for only one loop
                            z.shape = (mat_size,)
                            C.shape = (mat_size,)

                            for it in range(mat_size):
                                for ind in range(max_num):
                                    z[it] = iter_fun(z[it], C[it])

                                    if z[it] * np.conj(z[it]) &gt; limit**2:
                                        iters[it] = ind
                                        break

                            # all iterations that survived without passing limit went trough the entire loop
                            iters[iters == 0] = max_num

                            # change shape back to original
                            z.shape = mat_shape
                            C.shape = mat_shape
                            iters.shape = mat_shape
                            return z, iters


                        def iter_n_vec(z0, C, max_num, limit):
                            z = z0 * np.ones(C.shape, dtype=C.dtype)

                            # we only iterate until the limit is passed, then it is considered divergant
                            # use the "iters" as a indication of this
                            iters = np.zeros(C.shape, dtype=np.int32)
                            for ind in range(max_num):
                                z[iters == 0] = iter_fun(z[iters == 0], C[iters == 0])

                                # if the norm of z passes the limit, stop iteration by setting the value to the iteration integer
                                z_norm = z * np.conj(z)
                                z_norm_check = np.logical_and(z_norm &gt; limit**2, iters == 0)
                                iters[z_norm_check] = ind

                            # all iterations that survived so far went trough the entire loop
                            iters[iters == 0] = max_num
                            return z, iters


                        def mandelbrot_set(C_mat, max_num, limit, iter_fun):
                            z0 = 0.0 + 0.0j
                            Z, iters = iter_fun(z0, C_mat, max_num=max_num, limit=limit)
                            Z_norm = np.real(np.sqrt(Z * np.conj(Z)))
                            return Z_norm, iters


                        if __name__ == "__main__":
                            n_base = 300

                            xmin, xmax, xn = -0.45, -0.42, n_base
                            ymin, ymax, yn = -0.59, -0.55, n_base
                            xv = np.linspace(xmin, xmax, xn, dtype=np.float32)
                            yv = np.linspace(ymin, ymax, yn, dtype=np.float32)
                            X, Y = np.meshgrid(xv, yv)

                            max_num = 120
                            limit = 4.0

                            t0 = time.time()
                            Z_norm, iters = mandelbrot_set(
                                C_mat=X + Y * 1.0j, max_num=max_num, limit=limit, iter_fun=iter_n_loop
                            )
                            dtl = time.time() - t0
                            print(f"loop execution time {dtl} sec")

                            t0 = time.time()
                            Z_norm, iters = mandelbrot_set(
                                C_mat=X + Y * 1.0j, max_num=max_num, limit=limit, iter_fun=iter_n_vec
                            )
                            dtv = time.time() - t0
                            print(f"vectorized execution time {dtv} sec")
                            print(f"speedup {dtl/dtv}")
                    </code>
                </pre>
            </div>
        </section>

        <section
            data-auto-animate
        >
            <div class="centered-container">
                <h3 class="title">Optimization</h3>
                <pre data-id="code-animation" class="fragment show-code">
                    <code data-line-numbers data-trim class="language-python" style="height: 60vh;">
                        def iter_n_loop(z0, C, max_num, limit):
                            z = z0 * np.ones(C.shape, dtype=C.dtype)

                            mat_shape = z.shape
                            mat_size = z.size

                            # we only iterate until the limit is passed, then it is considered divergant
                            # use the "iters" as a indication of this
                            iters = np.zeros((mat_size,), dtype=np.int32)

                            # flatten for only one loop
                            z.shape = (mat_size,)
                            C.shape = (mat_size,)

                            for it in range(mat_size):
                                for ind in range(max_num):
                                    z[it] = iter_fun(z[it], C[it])

                                    if z[it] * np.conj(z[it]) &gt; limit**2:
                                        iters[it] = ind
                                        break

                            # all iterations that survived without passing limit went trough the entire loop
                            iters[iters == 0] = max_num

                            # change shape back to original
                            z.shape = mat_shape
                            C.shape = mat_shape
                            iters.shape = mat_shape
                            return z, iters
                    </code>
                </pre>
            </div>
        </section>

        <section
            data-auto-animate
        >
            <div class="centered-container">
                <h3 class="title">Optimization</h3>
                <pre data-id="code-animation" class="fragment show-code">
                    <code data-line-numbers data-trim class="language-python" style="height: 60vh;">
                        def iter_n_vec(z0, C, max_num, limit):
                            z = z0 * np.ones(C.shape, dtype=C.dtype)

                            # we only iterate until the limit is passed, then it is considered divergant
                            # use the "iters" as a indication of this
                            iters = np.zeros(C.shape, dtype=np.int32)
                            for ind in range(max_num):
                                z[iters == 0] = iter_fun(z[iters == 0], C[iters == 0])

                                # if the norm of z passes the limit, stop iteration by setting the value to the iteration integer
                                z_norm = z * np.conj(z)
                                z_norm_check = np.logical_and(z_norm &gt; limit**2, iters == 0)
                                iters[z_norm_check] = ind

                            # all iterations that survived so far went trough the entire loop
                            iters[iters == 0] = max_num
                            return z, iters
                    </code>
                </pre>
            </div>
        </section>

        <section
            data-auto-animate
        >
            <div class="centered-container">
                <h3 class="title">Optimization</h3>
                <pre class="show-code">
                    <code data-line-numbers data-trim class="language-python" style="height: 30vh;">
                        def iter_n_vec(z0, C, max_num, limit):
                            z = z0 * np.ones(C.shape, dtype=C.dtype)

                            # we only iterate until the limit is passed, then it is considered divergant
                            # use the "iters" as a indication of this
                            iters = np.zeros(C.shape, dtype=np.int32)
                            for ind in range(max_num):
                                z[iters == 0] = iter_fun(z[iters == 0], C[iters == 0])

                                # if the norm of z passes the limit, stop iteration by setting the value to the iteration integer
                                z_norm = z * np.conj(z)
                                z_norm_check = np.logical_and(z_norm &gt; limit**2, iters == 0)
                                iters[z_norm_check] = ind

                            # all iterations that survived so far went trough the entire loop
                            iters[iters == 0] = max_num
                            return z, iters
                    </code>
                </pre>
                <pre class="fragment show-code">
                    <code data-line-numbers data-trim class="language-plaintext">
                        $ python vectorization.py
                        loop execution time 6.237718343734741 sec
                        vectorized execution time 0.07863926887512207 sec
                        speedup 79.3206553540082
                    </code>
                </pre>
            </div>
        </section>

        <section
            data-auto-animate
        >
            <div class="centered-container">
                <h3 class="title">Optimization</h3>
                <pre data-id="code-animation1" class="fragment show-code">
                    <code data-line-numbers data-trim class="language-c" style="height: 65vh;">
                        #include &lt;stdio.h&gt;
                        #include &lt;math.h&gt;

                        int main() {
                            int size = 10000;
                            double x[size], y[size];

                            FILE *file = fopen("data.csv", "r");
                            double value;
                            int count;
                            while (!feof(file)) {
                                if (fscanf(file, "%lf,", &value) == 1) {
                                    if (count &lt; size) {
                                        x[count] = value;
                                    }
                                    else {
                                        y[count - size] = value;
                                    }
                                    count++;
                                }
                            }
                            fclose(file);

                            double r;
                            double dx, dy;
                            int total;
                            for(int i = 0; i &lt; size; i++) {
                                for(int j = 0; j &lt; size; j++) {
                                    dx = x[i] - x[j];
                                    dy = y[i] - y[j];
                                    r = sqrt(dx*dx + dy*dy);
                                    if (r &lt; 1.0) {
                                        total++;
                                    }
                                }
                            }

                            printf("Prob %f\n", ((float)total)/(size*size));
                            return 0;
                        }
                    </code>
                </pre>
            </div>
        </section>

        <section
            data-auto-animate
        >
            <div class="centered-container">
                <h3 class="title">Optimization</h3>
                <pre data-id="code-animation1" class="show-code">
                    <code data-line-numbers data-trim class="language-c" style="height: 65vh;">
                        #include &lt;stdio.h&gt;
                        #include &lt;math.h&gt;

                        int main() {
                            //  load data... 
                            double r;
                            double dx, dy;
                            int total;
                            for(int i = 0; i &lt; size; i++) {
                                for(int j = 0; j &lt; size; j++) {
                                    dx = x[i] - x[j];
                                    dy = y[i] - y[j];
                                    r = sqrt(dx*dx + dy*dy);
                                    if (r &lt; 1.0) {
                                        total++;
                                    }
                                }
                            }

                            printf("Prob %f\n", ((float)total)/(size*size));
                            return 0;
                        }
                    </code>
                </pre>
            </div>
        </section>

        <section
            data-auto-animate
        >
            <div class="centered-container">
                <h3 class="title">Optimization</h3>
                <pre class="show-code">
                    <code data-line-numbers data-trim class="language-c">
                        #include &lt;stdio.h&gt;
                        #include &lt;math.h&gt;
                        #include "data.h"

                        int main() {
                            //  load data... 
                            double r;
                            int total;
                            for(int i = 0; i &lt; size; i++) {
                                for(int j = 0; j &lt; size; j++) {
                                    r = (x[i] - x[j])*(x[i] - x[j]) + (y[i] - y[j])*(y[i] - y[j]);
                                    if (r &lt; 1.0) {
                                        total++;
                                    }
                                }
                            }

                            printf("Prob %f\n", ((float)total)/(size*size));
                            return 0;
                        }
                    </code>
                </pre>
            </div>
        </section>


        <section
            data-auto-animate
        >
            <div class="centered-container">
                <h3 class="title">Optimization</h3>
                <pre class="fragment show-code">
                    <code data-line-numbers data-trim class="language-plaintext">
                        $ hyperfine ./shaving_op_with_o0.o -N -r 5
                        Benchmark 1: ./shaving_op_with_o0.o
                          Time (mean ± σ):     889.1 ms ±   3.4 ms    [User: 883.9 ms, System: 0.6 ms]
                          Range (min … max):   886.3 ms … 894.0 ms    5 runs
                         
                        $ hyperfine ./shaving_op_without_o0.o -N -r 5
                        Benchmark 1: ./shaving_op_without_o0.o
                          Time (mean ± σ):     591.2 ms ±   3.3 ms    [User: 587.3 ms, System: 1.0 ms]
                          Range (min … max):   587.8 ms … 596.2 ms    5 runs
                    </code>
                </pre>
                <p class="fragment">1.5 speedup!</p>
            </div>
        </section>

        <section
            data-auto-animate
        >
            <div class="centered-container">
                <h3 class="title">Optimization</h3>
                <pre class="fragment show-code">
                    <code data-line-numbers data-trim class="language-plaintext">
                        $ hyperfine ./shaving_op_without_o3.o -N -r 100
                        Benchmark 1: ./shaving_op_without_o3.o
                          Time (mean ± σ):      27.7 ms ±   1.1 ms    [User: 26.7 ms, System: 0.7 ms]
                          Range (min … max):    26.2 ms …  31.3 ms    100 runs
                    </code>
                </pre>
                <p class="fragment">21.3 speedup?!?</p>
                <p class="fragment mark">The compiler seeing everything allows for optimizations!</p>
            </div>
        </section>

    </div>
</div>

